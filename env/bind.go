/*
Copyright 2021 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/
package env

import (
	"fmt"
	"os"
	"reflect"
	"regexp"
	"strings"
	"unsafe"
)

type field struct {
	env        env
	fieldName  string
	fieldType  *reflect.Type
	fieldValue *reflect.Value
	public     bool
}

// contains raw info about string tag field. e.g: default=hello,
type strTag struct {
	value  string
	exists bool
}

type env struct {
	value   string
	name    string
	tagName string
	def     strTag
	req     strTag
	present bool
}

type meta map[string]field

const ()

// Bind binds environment variables into structure
func Bind(s interface{}) (err error) {
	var meta meta
	if s == nil {
		return fmt.Errorf("invalid argument value (nil)")
	}
	v := reflect.ValueOf(s)
	t := reflect.TypeOf(s).Kind()
	if t != reflect.Ptr {
		return fmt.Errorf("argument must be pointer to structure")
	}
	if v.Elem().Kind() != reflect.Struct {
		return fmt.Errorf("argument must be pointer to structure")
	}
	meta, err = roll(v.Elem(), v.Elem().Type().Name(), "")
	if err != nil {
		return
	}
	err = bind(meta)
	return
}

// binds meta to structure pointer
func bind(m meta) (err error) {
	for k, v := range m {
		f := reflect.NewAt(v.fieldValue.Type(), unsafe.Pointer(v.fieldValue.UnsafeAddr())).Elem()
		switch v.fieldValue.Kind() {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			var i int
			i, err = integer(v.env)
			if err != nil {
				return
			}
			f.SetInt(int64(i))
			continue

		case reflect.Bool:
			var b bool
			b, err = boolean(v.env)
			if err != nil {
				return
			}
			f.SetBool(b)
			continue

		case reflect.Float32, reflect.Float64:
			var fl float64
			fl, err = float(v.env)
			if err != nil {
				return
			}
			f.SetFloat(fl)
			continue

		case reflect.String:
			var s string
			s = GetEnvAsStringOrFallback(v.env.name, v.env.def.value)
			f.SetString(s)
			continue

		case reflect.Slice:

			switch f.Interface().(type) {
			case []string:
				var ss []string
				ss = GetEnvAsArrayOfStringsOrFallback(v.env.name, v.env.def.asStringSlice())
				f.Set(reflect.ValueOf(ss))
				continue

			case []int, []int8, []int16, []int32, []int64:
				var is []int
				is, err = integerSlice(v.env)
				if err != nil {
					return
				}
				f.Set(reflect.ValueOf(is))
				continue

			case []float32, []float64:
				var fs []float64
				fs, err = floatSlice(v.env)
				if err != nil {
					return
				}
				f.Set(reflect.ValueOf(fs))
				continue

			case []bool:
				var bs []bool
				bs, err = boolSlice(v.env)
				if err != nil {
					return
				}
				f.Set(reflect.ValueOf(bs))
				continue

			default:
				err = fmt.Errorf("unsupported type %s: %s", k, v.fieldValue.Type().Name())
			}
		default:
			err = fmt.Errorf("unsupported type %s: %s", k, v.fieldValue.Type().Name())
			return
		}
	}
	return err
}

// recoursive function builds meta structure
func roll(value reflect.Value, n, prefix string) (m meta, err error) {
	const tagEnv = "env"

	m = meta{}
	for i := 0; i < value.NumField(); i++ {
		var e env
		vf := value.Field(i)
		tf := value.Type().Field(i)
		key := fmt.Sprintf("%s.%s", n, tf.Name)
		tag := tf.Tag.Get(tagEnv)
		if vf.Kind() == reflect.Struct {
			var sm meta
			prefix := strings.TrimPrefix(fmt.Sprintf("%s_%s", prefix, getTagName(tag)), "_")
			sm, err = roll(vf, key, prefix)
			if err != nil {
				return
			}
			for k, v := range sm {
				m[k] = v
			}
			continue
		}
		if tag == "" {
			continue
		}
		if e, err = parseTag(tag, prefix); err != nil {
			return
		}
		if !e.present && e.req.value == "true" {
			err = fmt.Errorf("%s is required", e.name)
			return
		}
		m[key] = field{
			env:        e,
			fieldName:  tf.Name,
			fieldType:  &tf.Type,
			fieldValue: &vf,
			public:     tf.IsExported(),
		}
	}
	return m, err
}

// parseTag, retrieves env info and metadata
func parseTag(tag, prefix string) (e env, err error) {
	var def, req strTag
	var tagName = getTagName(tag)
	req, err = getTagProperty(tag, "require")
	if err != nil {
		return
	}
	def, err = getTagProperty(tag, "default")
	if err != nil {
		return
	}
	envName := getEnvName(tagName, prefix)
	value, exists := os.LookupEnv(envName)
	e = env{
		name:    envName,
		tagName: tagName,
		value:   value,
		req:     req,
		def:     def,
		present: exists,
	}
	return
}

func getEnvName(envName, prefix string) string {
	if prefix != "" {
		return fmt.Sprintf("%s_%s", prefix, envName)
	}
	return envName
}

func getTagName(tag string) string {
	return regexp.MustCompile("[a-zA-Z_]+[a-zA-Z0-9_]*").FindString(tag)
}

// parses value from env tag and returns <tag value, tag value exists, error>
func getTagProperty(tag, t string) (r strTag, err error) {
	const arr = `\[\w*\s*\!*\@*\#*\$*\%*\^*\&*\**\(*\)*\_*\-*\+*\<*\>*\?*\~*\=*\,*\.*\/*\{*\}*\|*\;*\:*\/*\'*\"*\/*\\*`
	const scalar = `\[*\]*\w*\s*\!*\@*\#*\$*\%*\^*\&*\**\(*\)*\_*\-*\+*\<*\>*\?*\~*\=*\.*\/*\{*\}*\|*\;*\:*\/*\'*\"*\/*\\*`
	r = strTag{}
	var findRegex, removeRegex *regexp.Regexp
	//	findRegex, err = regexp.Compile(",\\s*" + t + "\\s*=((\\s*([\\[\\w*\\,*\\.*\\s*\\-*])*\\])|(\\s*\\w*\\.*\\-*)*)")
	findRegex, err = regexp.Compile(",\\s*" + t + "\\s*=((\\s*([" + arr + "])*\\])|(" + scalar + ")*)")
	if err != nil {
		err = fmt.Errorf("ivalid %s", t)
		return
	}
	removeRegex, err = regexp.Compile(",\\s*" + t + "\\s*=\\s*")
	if err != nil {
		err = fmt.Errorf("ivalid %s", t)
		return
	}
	match := findRegex.FindString(tag)
	if match == "" {
		return
	}
	remove := removeRegex.FindString(strings.ToLower(tag))
	r.value = strings.ReplaceAll(match, remove, "")
	r.exists = true
	return
}

func (t strTag) asStringSlice() (s []string) {
	if !t.exists {
		return
	}
	envdef := strings.TrimSuffix(strings.TrimPrefix(t.value, " "), " ")
	envdef = strings.TrimSuffix(strings.TrimPrefix(envdef, "["), "]")
	s = strings.Split(envdef, ",")
	if s[0] == "" {
		s = []string{}
	}
	return
}
